diff -Napur linux-linux4microchip-2024.04-old/drivers/net/dsa/microchip/ksz9477.c linux-linux4microchip-2024.04-new/drivers/net/dsa/microchip/ksz9477.c
--- linux-linux4microchip-2024.04-old/drivers/net/dsa/microchip/ksz9477.c	2025-08-28 15:20:49.046287210 -0700
+++ linux-linux4microchip-2024.04-new/drivers/net/dsa/microchip/ksz9477.c	2025-08-28 15:45:52.555115145 -0700
@@ -1276,6 +1276,8 @@ void ksz9477_config_cpu_port(struct dsa_
 	}
 }
 
+static u8 reserved_mcast_map[8] = { 0, 1, 3, 16, 32, 33, 2, 17 };
+
 int ksz9477_enable_stp_addr(struct ksz_device *dev)
 {
 	const u32 *masks;
@@ -1287,6 +1289,94 @@ int ksz9477_enable_stp_addr(struct ksz_d
 	/* Enable Reserved multicast table */
 	ksz_cfg(dev, REG_SW_LUE_CTRL_0, SW_RESV_MCAST_ENABLE, true);
 
+	/* The reserved multicast address table has 8 entries.  Each entry has
+	 * a default value of which port to forward.  It is assumed the host
+	 * port is the last port in most of the switches, but that is not the
+	 * case for KSZ9477 or maybe KSZ9897.  It is necessary to update the
+	 * table to forward to the right host port.
+	 */
+	if (dev->cpu_port != dev->info->port_cnt - 1) {
+		u8 last_port = (1 << (dev->info->port_cnt - 1));
+		bool update = false;
+		u8 ports;
+		int i;
+
+		for (i = 0; i < 8; i++) {
+			data = reserved_mcast_map[i] << 16;
+			data |= ALU_STAT_START | ALU_RESV_MCAST_ADDR |
+				masks[ALU_STAT_READ];
+			ret = ksz_write32(dev, REG_SW_ALU_STAT_CTRL__4, data);
+			if (ret < 0)
+				return ret;
+
+			/* wait to be finished */
+			ret = ksz9477_wait_alu_sta_ready(dev);
+			if (ret < 0)
+				return ret;
+
+			ret = ksz_read32(dev, REG_SW_ALU_VAL_B, &data);
+			if (ret < 0)
+				return ret;
+
+			ports = data & dev->port_mask;
+
+			/* This entry drops everything. */
+			if (!ports)
+				continue;
+
+			/* Not forwarding to all ports. */
+			if (ports != dev->port_mask) {
+				/* Replace the last port with the host port. */
+				if (ports == last_port) {
+					ports = BIT(dev->cpu_port);
+					update = true;
+
+				/* This entry does not forward to host port.
+				 * But if the host needs to process protocols
+				 * like MVRP and MMRP the host port needs to
+				 * be included.
+				 */
+				} else if (!(ports & last_port)) {
+					ports &= ~BIT(dev->cpu_port);
+					ports |= last_port;
+					update = true;
+				}
+				if (update) {
+					data &= ~dev->port_mask;
+					data |= ports;
+				}
+			}
+
+			/* Set Override bit for STP in the first entry. */
+			if (i == 0) {
+				update = true;
+				data |= ALU_V_OVERRIDE;
+			}
+			if (update) {
+				ret = ksz_write32(dev, REG_SW_ALU_VAL_B, data);
+				if (ret < 0)
+					return ret;
+
+				data = reserved_mcast_map[i] << 16;
+				data |= ALU_STAT_START | ALU_RESV_MCAST_ADDR |
+					masks[ALU_STAT_WRITE];
+				ret = ksz_write32(dev, REG_SW_ALU_STAT_CTRL__4,
+						  data);
+				if (ret < 0)
+					return ret;
+
+				/* wait to be finished */
+				ret = ksz9477_wait_alu_sta_ready(dev);
+				if (ret < 0)
+					return ret;
+			}
+		}
+
+		/* Do not need to execute following code if updated. */
+		if (update)
+			return 0;
+	}
+
 	/* Set the Override bit for forwarding BPDU packet to CPU */
 	ret = ksz_write32(dev, REG_SW_ALU_VAL_B,
 			  ALU_V_OVERRIDE | BIT(dev->cpu_port));
