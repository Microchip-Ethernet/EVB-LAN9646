diff -Napur linux-linux4microchip-2025.04-old/drivers/net/dsa/microchip/ksz8.c linux-linux4microchip-2025.04-new/drivers/net/dsa/microchip/ksz8.c
--- linux-linux4microchip-2025.04-old/drivers/net/dsa/microchip/ksz8.c	2025-04-25 12:11:41.000000000 -0700
+++ linux-linux4microchip-2025.04-new/drivers/net/dsa/microchip/ksz8.c	2025-06-19 15:48:28.930557639 -0700
@@ -1044,6 +1044,17 @@ int ksz8_r_phy(struct ksz_device *dev, u
 			return ret;
 
 		break;
+
+	/* No MMD access. */
+	case MII_MMD_CTRL:
+	case MII_MMD_DATA:
+		break;
+	case MII_TPISTATUS:
+		/* This register holds the PHY interrupt status for simulated
+		 * Micrel KSZ PHY.
+		 */
+		data = 0x0505;
+		break;
 	default:
 		processed = false;
 		break;
diff -Napur linux-linux4microchip-2025.04-old/drivers/net/dsa/microchip/ksz_common.c linux-linux4microchip-2025.04-new/drivers/net/dsa/microchip/ksz_common.c
--- linux-linux4microchip-2025.04-old/drivers/net/dsa/microchip/ksz_common.c	2025-06-19 15:46:09.053755111 -0700
+++ linux-linux4microchip-2025.04-new/drivers/net/dsa/microchip/ksz_common.c	2025-06-19 15:48:28.931557601 -0700
@@ -484,6 +484,8 @@ static const u16 ksz8795_regs[] = {
 	[REG_SW_PME_CTRL]		= 0x8003,
 	[REG_PORT_PME_STATUS]		= 0x8003,
 	[REG_PORT_PME_CTRL]		= 0x8007,
+	[S_INTR_STATUS]			= 0x7C,
+	[S_INTR_ENABLE]			= 0x7D,
 };
 
 static const u32 ksz8795_masks[] = {
@@ -557,6 +559,8 @@ static const u16 ksz8863_regs[] = {
 	[S_START_CTRL]			= 0x01,
 	[S_BROADCAST_CTRL]		= 0x06,
 	[S_MULTICAST_CTRL]		= 0x04,
+	[S_INTR_STATUS]			= 0xBC,
+	[S_INTR_ENABLE]			= 0xBB,
 };
 
 static const u32 ksz8863_masks[] = {
@@ -611,6 +615,8 @@ static const u16 ksz8895_regs[] = {
 	[S_START_CTRL]			= 0x01,
 	[S_BROADCAST_CTRL]		= 0x06,
 	[S_MULTICAST_CTRL]		= 0x04,
+	[S_INTR_STATUS]			= 0x7C,
+	[S_INTR_ENABLE]			= 0x7D,
 };
 
 static const u32 ksz8895_masks[] = {
@@ -658,6 +664,8 @@ static const u16 ksz9477_regs[] = {
 	[REG_SW_PME_CTRL]		= 0x0006,
 	[REG_PORT_PME_STATUS]		= 0x0013,
 	[REG_PORT_PME_CTRL]		= 0x0017,
+	[S_INTR_STATUS]			= REG_SW_PORT_INT_STATUS__1,
+	[S_INTR_ENABLE]			= REG_SW_PORT_INT_MASK__1,
 };
 
 static const u32 ksz9477_masks[] = {
@@ -2380,9 +2388,11 @@ static int ksz_phy_addr_to_port(struct k
 static int ksz_irq_phy_setup(struct ksz_device *dev)
 {
 	struct dsa_switch *ds = dev->ds;
+	struct ksz_irq *pirq = &dev->girq;
 	int phy, port;
 	int irq;
 	int ret;
+	int src;
 
 	for (phy = 0; phy < PHY_MAX_ADDR; phy++) {
 		if (BIT(phy) & ds->phys_mii_mask) {
@@ -2392,8 +2402,16 @@ static int ksz_irq_phy_setup(struct ksz_
 				goto out;
 			}
 
-			irq = irq_find_mapping(dev->ports[port].pirq.domain,
-					       PORT_SRC_PHY_INT);
+			/* Older switches do not have separate interrupts for
+			 * each port.  They only have 1 global interrupt for
+			 * PHY link indication.
+			 */
+			src = phy;
+			if (dev->info->port_nirqs) {
+				pirq = &dev->ports[phy].pirq;
+				src = PORT_SRC_PHY_INT;
+			}
+			irq = irq_find_mapping(pirq->domain, src);
 			if (irq < 0) {
 				ret = irq;
 				goto out;
@@ -2633,9 +2651,15 @@ static void ksz_irq_bus_sync_unlock(stru
 {
 	struct ksz_irq *kirq  = irq_data_get_irq_chip_data(d);
 	struct ksz_device *dev = kirq->dev;
+	u8 masked = kirq->masked;
 	int ret;
 
-	ret = ksz_write8(dev, kirq->reg_mask, kirq->masked);
+	/* Switches having only global interrupt use bits for enabling
+	 * interrupt rather than masking it.
+	 */
+	if (!dev->info->port_nirqs)
+		masked = ~masked;
+	ret = ksz_write8(dev, kirq->reg_mask, masked);
 	if (ret)
 		dev_err(dev->dev, "failed to change IRQ mask\n");
 
@@ -2696,6 +2720,15 @@ static irqreturn_t ksz_irq_thread_fn(int
 	if (ret)
 		goto out;
 
+	/* Switches that do not have separate port interrupt needs to
+	 * acknowledge the interrupt here.
+	 */
+	if (!dev->info->port_nirqs && data) {
+		ret = ksz_write8(dev, kirq->reg_status, data);
+		if (ret)
+			goto out;
+	}
+
 	for (n = 0; n < kirq->nirqs; ++n) {
 		if (data & BIT(n)) {
 			sub_irq = irq_find_mapping(kirq->domain, n);
@@ -2740,8 +2773,8 @@ static int ksz_girq_setup(struct ksz_dev
 	struct ksz_irq *girq = &dev->girq;
 
 	girq->nirqs = dev->info->port_cnt;
-	girq->reg_mask = REG_SW_PORT_INT_MASK__1;
-	girq->reg_status = REG_SW_PORT_INT_STATUS__1;
+	girq->reg_mask = dev->info->regs[S_INTR_ENABLE];
+	girq->reg_status = dev->info->regs[S_INTR_STATUS];
 	snprintf(girq->name, sizeof(girq->name), "global_port_irq");
 
 	girq->irq_num = dev->irq;
@@ -2770,6 +2803,7 @@ static int ksz_parse_drive_strength(stru
 static int ksz_setup(struct dsa_switch *ds)
 {
 	struct ksz_device *dev = ds->priv;
+	bool have_port_irq = false;
 	struct dsa_port *dp;
 	struct ksz_port *p;
 	const u16 *regs;
@@ -2833,11 +2867,15 @@ static int ksz_setup(struct dsa_switch *
 	p->learning = true;
 
 	if (dev->irq > 0) {
+		if (dev->info->port_nirqs)
+			have_port_irq = true;
 		ret = ksz_girq_setup(dev);
 		if (ret)
 			return ret;
 
 		dsa_switch_for_each_user_port(dp, dev->ds) {
+			if (!dev->info->port_nirqs)
+				break;
 			ret = ksz_pirq_setup(dev, dp->index);
 			if (ret)
 				goto out_girq;
@@ -2879,11 +2917,11 @@ out_ptp_clock_unregister:
 	if (dev->info->ptp_capable)
 		ksz_ptp_clock_unregister(ds);
 out_ptpirq:
-	if (dev->irq > 0 && dev->info->ptp_capable)
+	if (have_port_irq && dev->info->ptp_capable)
 		dsa_switch_for_each_user_port(dp, dev->ds)
 			ksz_ptp_irq_free(ds, dp->index);
 out_pirq:
-	if (dev->irq > 0)
+	if (have_port_irq)
 		dsa_switch_for_each_user_port(dp, dev->ds)
 			ksz_irq_free(&dev->ports[dp->index].pirq);
 out_girq:
diff -Napur linux-linux4microchip-2025.04-old/drivers/net/dsa/microchip/ksz_common.h linux-linux4microchip-2025.04-new/drivers/net/dsa/microchip/ksz_common.h
--- linux-linux4microchip-2025.04-old/drivers/net/dsa/microchip/ksz_common.h	2025-06-19 15:46:09.054755074 -0700
+++ linux-linux4microchip-2025.04-new/drivers/net/dsa/microchip/ksz_common.h	2025-06-19 15:48:28.931557601 -0700
@@ -269,6 +269,8 @@ enum ksz_regs {
 	REG_SW_PME_CTRL,
 	REG_PORT_PME_STATUS,
 	REG_PORT_PME_CTRL,
+	S_INTR_STATUS,
+	S_INTR_ENABLE,
 };
 
 enum ksz_masks {
