diff -Napur linux-linux4microchip-2025.04-old/drivers/net/dsa/microchip/ksz8.c linux-linux4microchip-2025.04-new/drivers/net/dsa/microchip/ksz8.c
--- linux-linux4microchip-2025.04-old/drivers/net/dsa/microchip/ksz8.c	2025-08-29 19:27:32.578543358 -0700
+++ linux-linux4microchip-2025.04-new/drivers/net/dsa/microchip/ksz8.c	2025-09-02 15:52:29.524659950 -0700
@@ -1961,6 +1961,18 @@ int ksz8_enable_stp_addr(struct ksz_devi
 	return ksz8_w_sta_mac_table(dev, 0, &alu);
 }
 
+#define KSZ8_REGS_SIZE		0x100
+
+static struct bin_attribute ksz8_registers_attr = {
+	.attr = {
+		.name	= "registers",
+		.mode	= 00600,
+	},
+	.size	= KSZ8_REGS_SIZE,
+	.read	= ksz_registers_read,
+	.write	= ksz_registers_write,
+};
+
 int ksz8_setup(struct dsa_switch *ds)
 {
 	struct ksz_device *dev = ds->priv;
@@ -2018,6 +2030,14 @@ int ksz8_setup(struct dsa_switch *ds)
 			ret = ksz_rmw8(dev, REG_INT_ENABLE, INT_PME, 0);
 	}
 
+	dev->regs_size = KSZ8_REGS_SIZE;
+	if (ksz_is_ksz8463(dev)) {
+		dev->regs_size = 0x800;
+		ksz8_registers_attr.size = dev->regs_size;
+	}
+	i = sysfs_create_bin_file(&dev->dev->kobj, &ksz8_registers_attr);
+	(void)i;
+
 	if (!ret)
 		return ksz8_handle_global_errata(ds);
 	else
@@ -2142,6 +2162,7 @@ int ksz8_switch_init(struct ksz_device *
 
 void ksz8_switch_exit(struct ksz_device *dev)
 {
+	sysfs_remove_bin_file(&dev->dev->kobj, &ksz8_registers_attr);
 	ksz8_reset_switch(dev);
 }
 
diff -Napur linux-linux4microchip-2025.04-old/drivers/net/dsa/microchip/ksz9477.c linux-linux4microchip-2025.04-new/drivers/net/dsa/microchip/ksz9477.c
--- linux-linux4microchip-2025.04-old/drivers/net/dsa/microchip/ksz9477.c	2025-08-29 19:05:31.487469070 -0700
+++ linux-linux4microchip-2025.04-new/drivers/net/dsa/microchip/ksz9477.c	2025-09-02 15:53:44.187804442 -0700
@@ -1475,6 +1475,18 @@ int ksz9477_enable_stp_addr(struct ksz_d
 	return 0;
 }
 
+#define KSZ9477_REGS_SIZE		0x8000
+
+static struct bin_attribute ksz9477_registers_attr = {
+	.attr = {
+		.name	= "registers",
+		.mode	= 00600,
+	},
+	.size	= KSZ9477_REGS_SIZE,
+	.read	= ksz_registers_read,
+	.write	= ksz_registers_write,
+};
+
 int ksz9477_setup(struct dsa_switch *ds)
 {
 	struct ksz_device *dev = ds->priv;
@@ -1509,6 +1521,11 @@ int ksz9477_setup(struct dsa_switch *ds)
 	/* enable global MIB counter freeze function */
 	ksz_cfg(dev, REG_SW_MAC_CTRL_6, SW_MIB_COUNTER_FREEZE, true);
 
+	dev->regs_size = KSZ9477_REGS_SIZE;
+	ret = sysfs_create_bin_file(&dev->dev->kobj,
+				    &ksz9477_registers_attr);
+	(void)ret;
+
 	/* Make sure PME (WoL) is not enabled. If requested, it will
 	 * be enabled by ksz_wol_pre_shutdown(). Otherwise, some PMICs
 	 * do not like PME events changes before shutdown.
@@ -1623,6 +1640,7 @@ void ksz9477_switch_exit(struct ksz_devi
 			p->xpcs = NULL;
 		}
 	}
+	sysfs_remove_bin_file(&dev->dev->kobj, &ksz9477_registers_attr);
 	ksz9477_reset_switch(dev);
 }
 
diff -Napur linux-linux4microchip-2025.04-old/drivers/net/dsa/microchip/ksz_common.c linux-linux4microchip-2025.04-new/drivers/net/dsa/microchip/ksz_common.c
--- linux-linux4microchip-2025.04-old/drivers/net/dsa/microchip/ksz_common.c	2025-08-29 19:27:32.579543319 -0700
+++ linux-linux4microchip-2025.04-new/drivers/net/dsa/microchip/ksz_common.c	2025-09-02 15:55:45.868150757 -0700
@@ -5023,6 +5023,98 @@ static const struct dsa_switch_ops ksz_s
 	.port_set_apptrust	= ksz_port_set_apptrust,
 };
 
+ssize_t ksz_registers_read(struct file *filp, struct kobject *kobj,
+			   struct bin_attribute *bin_attr, char *buf,
+			   loff_t off, size_t count)
+{
+	struct ksz_device *swdev;
+	struct device *dev;
+	struct regmap *map;
+	size_t cnt = count;
+	size_t i;
+	u32 reg;
+
+	dev = container_of(kobj, struct device, kobj);
+	swdev = dev_get_drvdata(dev);
+
+	if (unlikely(off >= swdev->regs_size))
+		return 0;
+
+	if ((off + count) >= swdev->regs_size)
+		count = swdev->regs_size - off;
+
+	if (unlikely(!count))
+		return count;
+
+	reg = off;
+	map = swdev->regmap[0];
+	if (swdev->chip_id == KSZ8463_CHIP_ID) {
+		if (!(count & 1) && !(reg & 1)) {
+			map = swdev->regmap[1];
+			cnt /= 2;
+		} else if (!(count & 3) && !(reg & 3)) {
+			map = swdev->regmap[2];
+			cnt /= 4;
+		}
+	}
+	i = regmap_bulk_read(map, reg, buf, cnt);
+	i = count;
+
+	/* 16-bit access with odd address. */
+	if (swdev->chip_id == KSZ8463_CHIP_ID && (off & 1)) {
+		/*
+		 * Return zero to let the calling program know the boundary
+		 * must be 16-bit.
+		 */
+		if (!(count & 1))
+			i = 0;
+	}
+	if (count == 1)
+		i = 1;
+	return i;
+}
+EXPORT_SYMBOL_GPL(ksz_registers_read);
+
+ssize_t ksz_registers_write(struct file *filp, struct kobject *kobj,
+			    struct bin_attribute *bin_attr, char *buf,
+			    loff_t off, size_t count)
+{
+	struct ksz_device *swdev;
+	struct device *dev;
+	struct regmap *map;
+	size_t cnt = count;
+	size_t i;
+	u32 reg;
+
+	dev = container_of(kobj, struct device, kobj);
+	swdev = dev_get_drvdata(dev);
+
+	if (unlikely(off >= swdev->regs_size))
+		return -EFBIG;
+
+	if ((off + count) >= swdev->regs_size)
+		count = swdev->regs_size - off;
+
+	if (unlikely(!count))
+		return count;
+
+	reg = off;
+	map = swdev->regmap[0];
+	if (swdev->chip_id == KSZ8463_CHIP_ID) {
+		if (!(count & 1) && !(reg & 1)) {
+			map = swdev->regmap[1];
+			cnt /= 2;
+		} else if (!(count & 3) && !(reg & 3)) {
+			map = swdev->regmap[2];
+			cnt /= 4;
+		}
+	}
+	i = regmap_bulk_write(map, reg, buf, cnt);
+	i = count;
+	return i;
+}
+EXPORT_SYMBOL_GPL(ksz_registers_write);
+
 struct ksz_device *ksz_switch_alloc(struct device *base, void *priv)
 {
 	struct dsa_switch *ds;
diff -Napur linux-linux4microchip-2025.04-old/drivers/net/dsa/microchip/ksz_common.h linux-linux4microchip-2025.04-new/drivers/net/dsa/microchip/ksz_common.h
--- linux-linux4microchip-2025.04-old/drivers/net/dsa/microchip/ksz_common.h	2025-08-29 19:27:32.580543281 -0700
+++ linux-linux4microchip-2025.04-new/drivers/net/dsa/microchip/ksz_common.h	2025-09-02 15:56:38.449139791 -0700
@@ -170,6 +170,7 @@ struct ksz_device {
 
 	struct device *dev;
 	struct regmap *regmap[__KSZ_NUM_REGMAPS];
+	u32 regs_size;
 
 	void *priv;
 	int irq;
@@ -472,6 +473,13 @@ void ksz_switch_macaddr_put(struct dsa_s
 void ksz_switch_shutdown(struct ksz_device *dev);
 int ksz_handle_wake_reason(struct ksz_device *dev, int port);
 
+ssize_t ksz_registers_read(struct file *filp, struct kobject *kobj,
+			   struct bin_attribute *bin_attr, char *buf,
+			   loff_t off, size_t count);
+ssize_t ksz_registers_write(struct file *filp, struct kobject *kobj,
+			    struct bin_attribute *bin_attr, char *buf,
+			    loff_t off, size_t count);
+
 /* Common register access functions */
 static inline struct regmap *ksz_regmap_8(struct ksz_device *dev)
 {
